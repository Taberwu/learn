/*
 * @Author: wuyuyang Taber.wu@joyson.cn
 * @Date: 2022-09-15 14:40:32
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2022-10-10 13:29:21
 * @FilePath: test.txt
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 */
#include <chrono>
#include <deque>
#include <map>
#include <memory>
#include <mutex>
#include <vector>
#include <iostream>
#include <random>
#include <thread>
#include <utility>
#include <variant>

#include <eigen3/Eigen/Core>
#include <eigen3/Eigen/Geometry>


using namespace std::chrono_literals;

class Message{
public:
    Message(){}
    virtual ~Message(){}
public:
    void setTimestamp(std::uint64_t timestamp)
    {
        timestamp_ = timestamp;
    }
    std::uint64_t getTimestamp()
    {
        return timestamp_;
    }
protected:
    std::uint64_t timestamp_;
};

class  LocalizationMessage : public Message{
public:
    enum class StatusType : std::int8_t{
        NotAvailable = 0,
        StartingUp = 1,
        Avalible = 2,
    };
    enum class PrecisionType : std::int8_t{
        Unknown = 0,
        HighPrecision = 1,
        MediumPrecision = 2,
        LowPrecision = 3,
    };
public:
    LocalizationMessage(){}
    virtual ~LocalizationMessage(){}
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
public:
    void setStatus(StatusType status){status_ = status;}
    const StatusType& getStatus() const{return status_;}
    void setPrecision(PrecisionType precision){precision_ = precision;}
    const PrecisionType& getPrecision() const{return precision_;}
    void setOrigin(const Eigen::Vector3d& origin){origin_ = origin;}
    const Eigen::Vector3d& getOrigin() const {return origin_;}
    void setLLA(const Eigen::Vector3d& lla){lla_ = lla;}
    const Eigen::Vector3d& getLLA() const {return lla_;}
    void setTranslation(const Eigen::Vector3d& translation){translation_ = translation;}
    const Eigen::Vector3d& getTranslation() const {return translation_;}
    void setVelocity(const Eigen::Vector3d& velocity){velocity_ = velocity;}
    const Eigen::Vector3d& getVelocity() const {return velocity_;}
    void setRotation(const Eigen::Quaterniond& rotation){rotation_ = rotation;}
    const Eigen::Quaterniond& getRotation() const {return rotation_;}
    void setAcceleration(const Eigen::Vector3d& acceleration){acceleration_ = acceleration;}
    const Eigen::Vector3d& getAcceleration() const{return acceleration_;}
    void setOmega(const Eigen::Vector3d& omega){omega_ = omega;}
    const Eigen::Vector3d& getOmega() const{return omega_;}
protected:
    StatusType status_;
    PrecisionType precision_;
    Eigen::Vector3d origin_;// latitude, longitude, altitude;
    Eigen::Vector3d lla_;// latitude, longitude, altitude;
    Eigen::Vector3d translation_;
    Eigen::Vector3d velocity_;
    Eigen::Quaterniond rotation_;
    Eigen::Vector3d acceleration_;
    Eigen::Vector3d omega_;
};

class WheelMessage : public Message{
    public:
        WheelMessage() : fr_speed_(0.), fl_speed_(0.), rr_speed_(0.), rl_speed_(0.) {}
        virtual ~WheelMessage(){}
    public:
        void setFRSpeed(const double& fr_speed){fr_speed_ = fr_speed;}
        const double& getFRSpeed() const {return fr_speed_;}
        void setFLSpeed(const double& fl_speed){fl_speed_ = fl_speed;}
        const double& getFLSpeed() const {return fl_speed_;}
        void setRRSpeed(const double& rr_speed){rr_speed_ = rr_speed;}
        const double& getRRSpeed() const {return rr_speed_;}
        void setRLSpeed(const double& rl_speed){rl_speed_ = rl_speed;}
        const double& getRLSpeed() const {return rl_speed_;}
        void setRRPluse(const uint32_t& wheeledges_rr){wheeledges_rr_ = wheeledges_rr;}
        void setRLPluse(const uint32_t& wheeledges_rl){wheeledges_rl_ = wheeledges_rl;}
        std::uint32_t getRPluse() const {return (wheeledges_rr_+wheeledges_rl_)/2;}
    protected:
        double fr_speed_;
        double fl_speed_;
        double rr_speed_;
        double rl_speed_;
        std::uint32_t wheeledges_rr_;
        std::uint32_t wheeledges_rl_;
    };

class InspvaMessage : public Message{
public:
    InspvaMessage(){}
    virtual ~InspvaMessage(){}
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
public:
    void setLLA(const Eigen::Vector3d& lla){lla_ = lla;}
    const Eigen::Vector3d& getLLA() const {return lla_;}
    void setVelocity(const Eigen::Vector3d& velocity){velocity_ = velocity;}
    const Eigen::Vector3d& getVelocity() const {return velocity_;}
    void setRotation(const Eigen::Quaterniond& rotation){rotation_ = rotation;}
    const Eigen::Quaterniond& getRotation() const {return rotation_;}
    void setLLAStd(const Eigen::Vector3d& noise){lla_std_ = noise;}
    const Eigen::Vector3d& getLLAStd() const {return lla_std_;}
    void setVelocityStd(const Eigen::Vector3d& noise){velocity_std_ = noise;}
    const Eigen::Vector3d& getVelocityStd() const {return velocity_std_;}
    void setRotationStd(const Eigen::Vector3d& noise){rotation_std_ = noise;}
    const Eigen::Vector3d& getRotationStd() const {return rotation_std_;}
protected:
    Eigen::Vector3d lla_;// latitude, longitude, altitude;
    Eigen::Vector3d velocity_;
    Eigen::Quaterniond rotation_;
    Eigen::Vector3d lla_std_;
    Eigen::Vector3d velocity_std_;
    Eigen::Vector3d rotation_std_;
};

int main(int argc,char **argv){
   

    // Eigen::Vector3d va(1,0,0);
    // Eigen::Vector3d vb(0,1,1);
    // Eigen::Vector3d vc(1,1,1);

    // auto tmp1=va.cross(vb);
    // auto tmp2=va.cross(Eigen::Vector3d(1,0,0));
    // auto tmp3= va.adjoint()*vb;
    // auto tmp4=vc-va;
    // auto tmp5=tmp4.norm();
    // auto tmp6 =(va-vb).norm();
    
 std::cout<<"start"<<std::endl;
    std::map<int,std::deque<std::variant<std::shared_ptr<LocalizationMessage>,std::shared_ptr<WheelMessage>,std::shared_ptr<InspvaMessage>>>> data;
  std::cout<<"create map"<<std::endl;  
    auto imuMsg = std::make_shared<LocalizationMessage>();
    auto rtkMsg = std::make_shared<InspvaMessage>();
    auto wheMsg = std::make_shared<WheelMessage>() ;
std::cout<<" input data"<<std::endl;
    for(int i = 0;i < 100;i++){
        imuMsg->setTimestamp(i*1000*1000);
        imuMsg->setRotation(Eigen::Quaterniond::UnitRandom());
        data[0].emplace_back(imuMsg);
        if(i%2==1){
            wheMsg->setTimestamp(i*1000*1000);
            wheMsg->setRLPluse(random()%5);
            wheMsg->setRRPluse(random()%5);
            data[1].emplace_back(wheMsg);
        }
        if(i%3==2){
            rtkMsg->setTimestamp(i*1000*1000);
            rtkMsg->setLLA(Eigen::Vector3d(31.4356-i/1000.0,121.3425+i/1000.0,(random()%50)/25.0));
            data[2].emplace_back(rtkMsg);
        }
        std::cout<<"imu size: "<<data[0].size()<<"  "<<std::get<0>(data[0].back())->getTimestamp()<<std::endl;
        if(data[1].size()!=0) std::cout<<"wheel size: "<<data[1].size()<<"  "<<std::get<1>(data[1].back())->getTimestamp()<<std::endl;
        if(data[2].size()!=0) std::cout<<"wheel size: "<<data[2].size()<<"  "<<std::get<2>(data[2].back())->getTimestamp()<<std::endl;
    }
    return 0;
}